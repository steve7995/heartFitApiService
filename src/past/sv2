import "dotenv/config";
import express from "express";
import session from "express-session";
import pool from "./db/pool.js";
import { google } from "googleapis";

const app = express();
const PORT = Number(process.env.PORT || 5000);

// Middleware
app.use(express.json());

app.use(
  session({
    secret: process.env.SESSION_SECRET || "change-me",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: false,
      sameSite: "lax",
      maxAge: 24 * 60 * 60 * 1000
    }
  })
);

// Config
const OAUTH_SCOPES = [
  "https://www.googleapis.com/auth/fitness.heart_rate.read",
  "https://www.googleapis.com/auth/userinfo.profile",
  "https://www.googleapis.com/auth/userinfo.email",
  "openid"
];

const SESSION_DEFAULT_MINUTES = Number(process.env.SESSION_DEFAULT_MINUTES || 20);
// const FETCH_BUFFER_MINUTES = Number(process.env.FETCH_BUFFER_MINUTES || 15);
const FETCH_BUFFER_MINUTES = Number(process.env.FETCH_BUFFER_MINUTES || 180);

function createOAuthClient() {
  return new google.auth.OAuth2(
    "45946153604-kkpr1i9t3pvkinhf624h0d4bhbui7u72.apps.googleusercontent.com",
    "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",
    "http://localhost:5000/auth/google/callback"
  );
}   

// Helper functions
function nsRangeFromMs(msStart, msEnd) {
  const startNs = (BigInt(msStart) * 1000000n).toString();
  const endNs = (BigInt(msEnd) * 1000000n).toString();
  return `${startNs}-${endNs}`;
}

async function getUserById(userId) {
  const [rows] = await pool.query("SELECT * FROM users WHERE user_id = ?", [userId]);
  return rows[0] || null;
}

async function updateUserTokens(userId, accessToken, expiry, refreshTokenMaybe) {
  const params = [accessToken, new Date(expiry), userId];
  let sql = "UPDATE users SET access_token = ?, token_expiry = ? WHERE user_id = ?";

  if (refreshTokenMaybe) {
    sql = "UPDATE users SET access_token = ?, token_expiry = ?, refresh_token = ? WHERE user_id = ?";
    params.splice(2, 0, refreshTokenMaybe);
  }
  
  const [result] = await pool.query(sql, params);
  
  if (result.affectedRows === 0) {
    throw new Error(`Failed to update tokens for user ${userId} - user not found`);
  }
}

async function ensureValidAccessTokenWithRetry(user, maxRetries = 3) {
  const now = Date.now();
  const expiry = new Date(user.token_expiry).getTime();
  
  // Check if token is still valid with 5-minute buffer
  if (now < expiry - 5 * 60 * 1000) {
    return user.access_token;
  }

  if (!user.refresh_token || user.refresh_token.trim() === '') {
    throw new Error(`No refresh token available for user ${user.user_id}. User needs to re-authenticate.`);
  }

  let lastError = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const payload = new URLSearchParams({
        client_id: "45946153604-kkpr1i9t3pvkinhf624h0d4bhbui7u72.apps.googleusercontent.com",
        client_secret: "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",
        refresh_token: user.refresh_token,
        grant_type: "refresh_token"
      });

      const resp = await fetch("https://oauth2.googleapis.com/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: payload.toString(),
        timeout: 10000
      });

      if (!resp.ok) {
        const errorText = await resp.text();
        const error = new Error(`Token refresh failed: ${resp.status} ${errorText}`);
        
        if (resp.status === 400) {
          try {
            const errorData = JSON.parse(errorText);
            if (errorData.error === 'invalid_grant') {
              await markUserTokensInvalid(user.user_id);
              throw new Error(`Refresh token invalid for user ${user.user_id}. User needs to re-authenticate.`);
            }
          } catch (parseError) {
            // Continue with original error if JSON parse fails
          }
        }
        
        if (resp.status >= 500 && attempt < maxRetries) {
          lastError = error;
          const delay = Math.pow(2, attempt - 1) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        } else {
          throw error;
        }
      } else {
        const json = await resp.json();
        const newAccess = json.access_token;
        const expiresInMs = (json.expires_in || 3600) * 1000;
        const newExpiry = Date.now() + expiresInMs;

        await updateUserTokens(user.user_id, newAccess, newExpiry);
        return newAccess;
      }
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT')) {
        const delay = Math.pow(2, attempt - 1) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      if (attempt === maxRetries) {
        break;
      }
    }
  }

  throw new Error(`Token refresh failed after ${maxRetries} attempts. Last error: ${lastError?.message}`);
}

async function markUserTokensInvalid(userId) {
  await pool.query(
    "UPDATE users SET access_token = '', refresh_token = '', token_expiry = NULL, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?",
    [userId]
  );
}

async function insertHeartRatePoints({ userId, sessionId, startMs, endMs, points }) {
  if (!points || !points.length) return 0;
  let inserted = 0;

  const conn = await pool.getConnection();
  try {
    await conn.beginTransaction();
    for (const p of points) {
      const tsMs = Number(p.startTimeNanos) / 1e6;
      if (Number.isNaN(tsMs)) continue;
      if (tsMs < startMs || tsMs > endMs) continue;

      const bpm = p.value?.[0]?.fpVal;
      if (typeof bpm !== "number") continue;

      await conn.query(
        "INSERT IGNORE INTO heart_rate (user_id, session_id, bpm, timestamp, source) VALUES (?, ?, ?, FROM_UNIXTIME(?/1000), ?)",
        [userId, sessionId, Math.round(bpm), tsMs, p.originDataSourceId || "google_fit"]
      );
      inserted++;
    }
    await conn.commit();
  } catch (e) {
    await conn.rollback();
    throw e;
  } finally {
    conn.release();
  }
  return inserted;
}

async function upsertMeanResult(userId, sessionId) {
  const [[row]] = await pool.query(
    "SELECT AVG(bpm) AS mean_bpm FROM heart_rate WHERE user_id = ? AND session_id = ?",
    [userId, sessionId]
  );
  const mean = row?.mean_bpm;
  if (mean == null) return 0;

  await pool.query(
    `INSERT INTO results (user_id, session_id, mean_bpm)
     VALUES (?, ?, ?)
     ON DUPLICATE KEY UPDATE mean_bpm = VALUES(mean_bpm), updated_at = CURRENT_TIMESTAMP`,
    [userId, sessionId, mean]
  );
  return Number(mean);
}

async function logFetch({ sessionId, userId, attemptNumber, status, message }) {
  await pool.query(
    "INSERT INTO fetch_logs (session_id, user_id, attempt_number, status, message) VALUES (?, ?, ?, ?, ?)",
    [sessionId, userId, attemptNumber, status, message?.slice(0, 5000) || null]
  );
}

function msAddMinutes(ms, mins) {
  return ms + mins * 60 * 1000;
}

async function fetchGoogleFitDataset({ accessToken, dataSourceId, startMs, endMs }) {
  const datasetId = nsRangeFromMs(startMs, endMs);
  const url = `https://www.googleapis.com/fitness/v1/users/me/dataSources/${encodeURIComponent(
    dataSourceId
  )}/datasets/${datasetId}`;

  const resp = await fetch(url, {
    method: "GET",
    headers: { Authorization: `Bearer ${accessToken}` }
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`Dataset API ${resp.status}: ${text}`);
  }

  const json = await resp.json();
  return json.point || [];
}

async function runFetchForSession({ session, attemptNumber, manual = false }) {
  const user = await getUserById(session.user_id);
  if (!user) throw new Error("User not found for session");

  // Always ensure valid token before API call
  const accessToken = await ensureValidAccessTokenWithRetry(user);

  const bufferMs = FETCH_BUFFER_MINUTES * 60 * 1000;
  const startMs = new Date(session.start_time).getTime();
  const endMs = new Date(session.end_time).getTime();
  const adjustedStart = startMs - bufferMs;
  const adjustedEnd = endMs + bufferMs;

  const dataSourceId = "derived:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm";

  try {
    const points = await fetchGoogleFitDataset({
      accessToken,
      dataSourceId,
      startMs: adjustedStart,
      endMs: adjustedEnd
    });

    const inserted = await insertHeartRatePoints({
      userId: session.user_id,
      sessionId: session.id,
      startMs,
      endMs,
      points
    });

    let status = "no_data";
    let msg = `Inserted ${inserted} points`;

    if (inserted > 0) {
      const mean = await upsertMeanResult(session.user_id, session.id);
      await pool.query(
        "UPDATE sessions SET fetch_status = 'fetched', status = 'completed', updated_at = CURRENT_TIMESTAMP WHERE id = ?",
        [session.id]
      );
      status = "success";
      msg += `; mean_bpm=${mean}`;
    } else {
      const isFinal = !manual && attemptNumber >= 5;
      await pool.query(
        "UPDATE sessions SET fetch_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
        [isFinal ? "failed" : "retry", session.id]
      );
      if (isFinal) {
        await pool.query(
          "UPDATE sessions SET status = 'failed', updated_at = CURRENT_TIMESTAMP WHERE id = ?",
          [session.id]
        );
      }
    }

    await logFetch({
      sessionId: session.id,
      userId: session.user_id,
      attemptNumber: manual ? 99 : attemptNumber,
      status,
      message: msg
    });

    return { ok: true, inserted };
  } catch (err) {
    await logFetch({
      sessionId: session.id,
      userId: session.user_id,
      attemptNumber: manual ? 99 : attemptNumber,
      status: "failed",
      message: err.message
    });

    const isFinal = !manual && attemptNumber >= 5;
    if (isFinal) {
      await pool.query(
        "UPDATE sessions SET fetch_status='failed', status='failed', updated_at=CURRENT_TIMESTAMP WHERE id=?",
        [session.id]
      );
    } else {
      await pool.query(
        "UPDATE sessions SET fetch_status='retry', updated_at=CURRENT_TIMESTAMP WHERE id=?",
        [session.id]
      );
    }
    return { ok: false, error: err.message };
  }
}

// Auth routes
app.get("/auth/google", (req, res) => {
  const oauth2Client = createOAuthClient();
  const url = oauth2Client.generateAuthUrl({
    access_type: "offline",
    prompt: "consent",
    scope: OAUTH_SCOPES
  });
  return res.redirect(url);
});

app.get("/auth/google/callback", async (req, res) => {
  const code = req.query.code;
  if (!code) return res.status(400).send("Missing authorization code");

  const oauth2Client = createOAuthClient();
  try {
    const { tokens } = await oauth2Client.getToken(code);
    oauth2Client.setCredentials(tokens);

    const oauth2 = google.oauth2({ version: "v2", auth: oauth2Client });
    const { data: profile } = await oauth2.userinfo.get();

    const userId = profile.id;
    const email = profile.email;
    const name = profile.name;
    const picture = profile.picture;

    const accessToken = tokens.access_token;
    const refreshToken = tokens.refresh_token;
    const expiryMs = tokens.expiry_date || (Date.now() + 3600 * 1000);

    await pool.query(
      `INSERT INTO users (user_id, email, google_id, access_token, refresh_token, token_expiry, name, picture)
       VALUES (?, ?, ?, ?, ?, FROM_UNIXTIME(?/1000), ?, ?)
       ON DUPLICATE KEY UPDATE
         email = VALUES(email),
         google_id = VALUES(google_id),
         access_token = VALUES(access_token),
         refresh_token = COALESCE(VALUES(refresh_token), refresh_token),
         token_expiry = VALUES(token_expiry),
         name = VALUES(name),
         picture = VALUES(picture),
         updated_at = CURRENT_TIMESTAMP`,
      [userId, email, profile.id, accessToken, refreshToken || "", expiryMs, name || null, picture || null]
    );

    req.session.userId = userId;
    req.session.email = email;

    res.redirect("/dashboard");
  } catch (err) {
    console.error("OAuth error:", err);
    res.status(500).send("Authentication failed");
  }
});

app.post("/auth/logout", (req, res) => {
  req.session.destroy(() => {});
  res.json({ message: "Logged out (soft). Background sync still possible." });
});

app.post("/auth/disconnect", async (req, res) => {
  try {
    const userId = req.session.userId;
    if (!userId) return res.status(401).json({ error: "Not authenticated" });

    const user = await getUserById(userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    const revokeResp = await fetch("https://oauth2.googleapis.com/revoke", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ token: user.refresh_token })
    });

    if (!revokeResp.ok) {
      console.warn("Token revoke failed:", await revokeResp.text());
    }

    await pool.query(
      "UPDATE users SET access_token='', refresh_token='', token_expiry=NULL, updated_at=CURRENT_TIMESTAMP WHERE user_id=?",
      [userId]
    );

    req.session.destroy(() => {});
    res.json({ message: "Disconnected from Google and logged out." });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to disconnect" });
  }
});

app.get("/dashboard", (req, res) => {
  if (!req.session.userId) {
    return res.status(401).send(`<h2>Not authenticated</h2><p><a href="/auth/google">Login with Google</a></p>`);
  }
  res.send(`<h1>Welcome!</h1><p>Signed in as ${req.session.email}</p>`);
});

// Session management
app.post("/sessions", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });

    const minutes = Number(req.query.minutes || SESSION_DEFAULT_MINUTES);
    const now = Date.now();
    const start = new Date(now);
    const end = new Date(msAddMinutes(now, minutes));

    const [result] = await pool.query(
      "INSERT INTO sessions (user_id, start_time, end_time, status, fetch_status) VALUES (?, ?, ?, 'pending', 'not_fetched')",
      [req.session.userId, start, end]
    );
    
    res.json({
      sessionId: result.insertId,
      start_time: start.toISOString(),
      end_time: end.toISOString(),
      duration_minutes: minutes
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to create session" });
  }
});

app.post("/sessions/:id/end", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });

    const { id } = req.params;
    const now = new Date();
    const [r] = await pool.query(
      "UPDATE sessions SET end_time = ?, status='completed', updated_at=CURRENT_TIMESTAMP WHERE id=? AND user_id=?",
      [now, id, req.session.userId]
    );
    if (r.affectedRows === 0) return res.status(404).json({ error: "Session not found" });
    res.json({ message: "Session ended", end_time: now.toISOString() });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to end session" });
  }
});

app.post("/sessions/:id/sync-now", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });
    const { id } = req.params;

    const [[session]] = await pool.query(
      "SELECT * FROM sessions WHERE id=? AND user_id=?",
      [id, req.session.userId]
    );
    if (!session) return res.status(404).json({ error: "Session not found" });

    const out = await runFetchForSession({ session, attemptNumber: 99, manual: true });
    res.json({ message: "Manual sync attempted", ...out });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Manual sync failed", details: e.message });
  }
});

app.get("/results/:sessionId", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });
    const { sessionId } = req.params;
    const [[row]] = await pool.query(
      "SELECT * FROM results WHERE session_id = ? AND user_id = ?",
      [sessionId, req.session.userId]
    );
    if (!row) return res.status(404).json({ error: "Result not ready" });
    res.json(row);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to fetch result" });
  }
});

app.get("/data-sources", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });
    const user = await getUserById(req.session.userId);
    const accessToken = await ensureValidAccessTokenWithRetry(user);

    const url = "https://www.googleapis.com/fitness/v1/users/me/dataSources";
    const resp = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });

    if (!resp.ok) return res.status(resp.status).send(await resp.text());
    const data = await resp.json();

    const sources = (data.dataSource || [])
      .filter(ds => (ds.dataType?.name || "").includes("heart_rate"))
      .map(ds => ({
        dataStreamId: ds.dataStreamId,
        dataTypeName: ds.dataType?.name,
        application: ds.application?.name || "Unknown",
        device: ds.device?.model || "Unknown"
      }));

    res.json({ totalSources: sources.length, sources });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to list data sources" });
  }
});

// Browser-friendly endpoints
app.get("/sessions/create", async (req, res) => {
  try {
    if (!req.session.userId) {
      return res
        .status(401)
        .send(`<h2>Not authenticated</h2><p><a href="/auth/google">Login with Google</a></p>`);
    }

    const minutes = Number(req.query.minutes || SESSION_DEFAULT_MINUTES);
    const now = Date.now();
    const start = new Date(now);
    const end = new Date(msAddMinutes(now, minutes));

    const [result] = await pool.query(
      "INSERT INTO sessions (user_id, start_time, end_time, status, fetch_status) VALUES (?, ?, ?, 'pending', 'not_fetched')",
      [req.session.userId, start, end]
    );

    res.send(`
      <h2>Session created!</h2>
      <p>Session ID: ${result.insertId}</p>
      <p>Start: ${start.toISOString()}</p>
      <p>End: ${end.toISOString()}</p>
      <p>Duration: ${minutes} minutes</p>
      <p><a href="/sessions/${result.insertId}">View session details</a></p>
    `);
  } catch (e) {
    console.error(e);
    res.status(500).send("Failed to create session");
  }
});

app.get("/sessions/:id", async (req, res) => {
  try {
    if (!req.session.userId) {
      return res
        .status(401)
        .send(`<h2>Not authenticated</h2><p><a href="/auth/google">Login with Google</a></p>`);
    }

    const sessionId = req.params.id;

    const [rows] = await pool.query(
      "SELECT * FROM sessions WHERE id = ? AND user_id = ?",
      [sessionId, req.session.userId]
    );

    if (!rows.length) {
      return res.status(404).send("Session not found");
    }

    const session = rows[0];

    if (req.headers.accept && req.headers.accept.includes("application/json")) {
      return res.json(session);
    }

    res.send(`
      <h2>Session Details</h2>
      <ul>
        <li><b>ID:</b> ${session.id}</li>
        <li><b>User ID:</b> ${session.user_id}</li>
        <li><b>Status:</b> ${session.status}</li>
        <li><b>Fetch Status:</b> ${session.fetch_status}</li>
        <li><b>Start:</b> ${new Date(session.start_time).toLocaleString()}</li>
        <li><b>End:</b> ${new Date(session.end_time).toLocaleString()}</li>
        <li><b>Created At:</b> ${new Date(session.created_at).toLocaleString()}</li>
      </ul>

      <p><a href="/sessions/create">Create another session</a></p>
    `);
  } catch (e) {
    console.error(e);
    res.status(500).send("Failed to fetch session details");
  }
});


// Add these debug routes to your server.js

// Route 1: Fetch data between two timestamps
app.get("/debug/fetch-range", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });
    
    const { start, end } = req.query;
    
    if (!start || !end) {
      return res.status(400).json({ 
        error: "Missing parameters", 
        usage: "/debug/fetch-range?start=2024-01-01T10:00:00Z&end=2024-01-01T11:00:00Z" 
      });
    }
    
    const startMs = new Date(start).getTime();
    const endMs = new Date(end).getTime();
    
    if (isNaN(startMs) || isNaN(endMs)) {
      return res.status(400).json({ error: "Invalid timestamp format. Use ISO format like 2024-01-01T10:00:00Z" });
    }
    
    if (startMs >= endMs) {
      return res.status(400).json({ error: "Start time must be before end time" });
    }

    const user = await getUserById(req.session.userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    const accessToken = await ensureValidAccessTokenWithRetry(user);

    // Try multiple data sources
    const dataSources = [
      "derived:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm",
      "raw:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm",
      "derived:com.google.heart_rate.bpm:com.google.android.gms:resting_heart_rate",
    ];

    const results = {};
    let totalPoints = 0;

    for (const dataSourceId of dataSources) {
      try {
        console.log(`Trying data source: ${dataSourceId}`);
        const points = await fetchGoogleFitDataset({
          accessToken,
          dataSourceId,
          startMs,
          endMs
        });
        
        results[dataSourceId] = {
          success: true,
          pointCount: points.length,
          points: points.slice(0, 5), // First 5 points for preview
          sampleData: points.map(p => ({
            timestamp: new Date(Number(p.startTimeNanos) / 1e6).toISOString(),
            bpm: p.value?.[0]?.fpVal || p.value?.[0]?.intVal,
            source: p.originDataSourceId
          })).slice(0, 10)
        };
        totalPoints += points.length;
      } catch (error) {
        results[dataSourceId] = {
          success: false,
          error: error.message
        };
      }
    }

    res.json({
      query: {
        start: new Date(startMs).toISOString(),
        end: new Date(endMs).toISOString(),
        durationMinutes: Math.round((endMs - startMs) / 60000)
      },
      summary: {
        totalDataSources: dataSources.length,
        successfulSources: Object.values(results).filter(r => r.success).length,
        totalPoints
      },
      results
    });

  } catch (error) {
    console.error("Debug fetch error:", error);
    res.status(500).json({ 
      error: "Debug fetch failed", 
      details: error.message 
    });
  }
});

// Route 2: Fetch last 24 hours of data
app.get("/debug/fetch-24h", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });

    const now = Date.now();
    const twentyFourHoursAgo = now - (24 * 60 * 60 * 1000);

    const user = await getUserById(req.session.userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    const accessToken = await ensureValidAccessTokenWithRetry(user);

    const dataSources = [
      "derived:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm",
      "raw:com.google.heart_rate.bpm:com.google.android.gms:merge_heart_rate_bpm",
    ];

    const results = {};
    let totalPoints = 0;
    const hourlyBreakdown = {};

    for (const dataSourceId of dataSources) {
      try {
        const points = await fetchGoogleFitDataset({
          accessToken,
          dataSourceId,
          startMs: twentyFourHoursAgo,
          endMs: now
        });

        // Analyze data by hour
        const pointsByHour = {};
        points.forEach(p => {
          const timestamp = Number(p.startTimeNanos) / 1e6;
          const hour = new Date(timestamp).getHours();
          pointsByHour[hour] = (pointsByHour[hour] || 0) + 1;
        });

        results[dataSourceId] = {
          success: true,
          pointCount: points.length,
          pointsByHour,
          latestPoints: points
            .slice(-10)
            .map(p => ({
              timestamp: new Date(Number(p.startTimeNanos) / 1e6).toISOString(),
              bpm: p.value?.[0]?.fpVal || p.value?.[0]?.intVal,
              source: p.originDataSourceId
            })),
          avgBpm: points.length > 0 ? 
            points.reduce((sum, p) => sum + (p.value?.[0]?.fpVal || 0), 0) / points.length : 0
        };
        
        totalPoints += points.length;

        // Merge into overall hourly breakdown
        Object.keys(pointsByHour).forEach(hour => {
          hourlyBreakdown[hour] = (hourlyBreakdown[hour] || 0) + pointsByHour[hour];
        });

      } catch (error) {
        results[dataSourceId] = {
          success: false,
          error: error.message
        };
      }
    }

    res.json({
      query: {
        start: new Date(twentyFourHoursAgo).toISOString(),
        end: new Date(now).toISOString(),
        durationHours: 24
      },
      summary: {
        totalPoints,
        averagePointsPerHour: Math.round(totalPoints / 24),
        activePeriods: Object.keys(hourlyBreakdown).length,
        peakHour: Object.keys(hourlyBreakdown).reduce((a, b) => 
          hourlyBreakdown[a] > hourlyBreakdown[b] ? a : b, "0")
      },
      hourlyBreakdown,
      results
    });

  } catch (error) {
    console.error("24h fetch error:", error);
    res.status(500).json({ 
      error: "24h fetch failed", 
      details: error.message 
    });
  }
});

// Route 3: Explore all available data sources for the user
app.get("/debug/explore-sources", async (req, res) => {
  try {
    if (!req.session.userId) return res.status(401).json({ error: "Not authenticated" });

    const user = await getUserById(req.session.userId);
    if (!user) return res.status(404).json({ error: "User not found" });

    const accessToken = await ensureValidAccessTokenWithRetry(user);

    // Get all data sources
    const sourcesUrl = "https://www.googleapis.com/fitness/v1/users/me/dataSources";
    const sourcesResp = await fetch(sourcesUrl, { 
      headers: { Authorization: `Bearer ${accessToken}` } 
    });

    if (!sourcesResp.ok) {
      return res.status(sourcesResp.status).json({ 
        error: "Failed to fetch data sources",
        details: await sourcesResp.text()
      });
    }

    const sourcesData = await sourcesResp.json();
    const allSources = sourcesData.dataSource || [];

    // Filter for heart rate related sources
    const heartRateSources = allSources.filter(ds => 
      (ds.dataType?.name || "").toLowerCase().includes("heart_rate") ||
      (ds.dataStreamId || "").toLowerCase().includes("heart_rate")
    );

    // Test each heart rate source with last 2 hours of data
    const twoHoursAgo = Date.now() - (2 * 60 * 60 * 1000);
    const now = Date.now();

    const sourceTests = [];
    
    for (const source of heartRateSources) {
      try {
        const points = await fetchGoogleFitDataset({
          accessToken,
          dataSourceId: source.dataStreamId,
          startMs: twoHoursAgo,
          endMs: now
        });

        sourceTests.push({
          dataStreamId: source.dataStreamId,
          dataTypeName: source.dataType?.name,
          application: source.application?.name || "Unknown",
          device: source.device?.model || source.device?.manufacturer || "Unknown",
          hasData: points.length > 0,
          pointCount: points.length,
          samplePoint: points[0] ? {
            timestamp: new Date(Number(points[0].startTimeNanos) / 1e6).toISOString(),
            bpm: points[0].value?.[0]?.fpVal || points[0].value?.[0]?.intVal,
            originSource: points[0].originDataSourceId
          } : null
        });

      } catch (error) {
        sourceTests.push({
          dataStreamId: source.dataStreamId,
          dataTypeName: source.dataType?.name,
          application: source.application?.name || "Unknown",
          device: source.device?.model || "Unknown",
          hasData: false,
          error: error.message
        });
      }
    }

    // Find sources with data
    const sourcesWithData = sourceTests.filter(s => s.hasData);

    res.json({
      summary: {
        totalSources: allSources.length,
        heartRateSources: heartRateSources.length,
        sourcesWithData: sourcesWithData.length,
        testPeriod: "Last 2 hours"
      },
      recommendedSources: sourcesWithData.map(s => s.dataStreamId),
      allHeartRateSources: sourceTests,
      testPeriod: {
        start: new Date(twoHoursAgo).toISOString(),
        end: new Date(now).toISOString()
      }
    });

  } catch (error) {
    console.error("Source exploration error:", error);
    res.status(500).json({ 
      error: "Source exploration failed", 
      details: error.message 
    });
  }
});


app.get("/", (req, res) => {
  res.send("Fit Heart API is running");
});

app.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
});